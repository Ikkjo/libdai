<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libDAI: Ideas worth exploring</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libDAI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Ideas worth exploring</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>File <a class="el" href="bp__dual_8h.html">bp_dual.h</a>  </dt>
<dd><a class="anchor" id="_ideas000003"></a> BP_dual replicates a large part of the functionality of BP; would it not be more efficient to adapt BP instead?  </dd>
<dt>Class <a class="el" href="classdai_1_1BipartiteGraph.html">dai::BipartiteGraph</a>  </dt>
<dd><a class="anchor" id="_ideas000002"></a> Cache second-order neighborhoods in <a class="el" href="classdai_1_1BipartiteGraph.html" title="Represents the neighborhood structure of nodes in an undirected, bipartite graph.">BipartiteGraph</a>.  </dd>
<dt>Member <a class="el" href="classdai_1_1CBP.html#ae5315044de332e92a6ed12acce7f0f75">dai::CBP::runRecurse</a>  (<a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a> *bp, Real orig_logZ, std::vector&lt; size_t &gt; clamped_vars_list, size_t &amp;num_leaves, size_t &amp;choose_count, Real &amp;sum_level, Real &amp;lz_out, std::vector&lt; Factor &gt; &amp;beliefs_out)</dt>
<dd><a class="anchor" id="_ideas000001"></a> <a class="el" href="classdai_1_1CBP.html#ae5315044de332e92a6ed12acce7f0f75" title="Called by run(), and by itself. Implements the main algorithm.">dai::CBP::runRecurse()</a> could be implemented more efficiently with a nesting version of backupFactors/restoreFactors  </dd>
<dt>Class <a class="el" href="classdai_1_1DAIAlg.html">dai::DAIAlg&lt; GRM &gt;</a>  </dt>
<dd><a class="anchor" id="_ideas000005"></a> A <a class="el" href="classdai_1_1DAIAlg.html" title="Combines the abstract base class InfAlg with a graphical model (e.g., a FactorGraph or RegionGraph).">DAIAlg</a> should not inherit from a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> or <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a>, but should store a reference to the graphical model object. This prevents needless copying of (possibly large) data structures. Disadvantage: the caller must not change the graphical model between calls to the inference algorithm (maybe a smart_ptr or some locking mechanism would help here?).  </dd>
<dt>Class <a class="el" href="classdai_1_1FactorGraph.html">dai::FactorGraph</a>  </dt>
<dd><a class="anchor" id="_ideas000010"></a> Alternative implementation of undo factor changes: the only things that have to be undone currently are setting a factor to 1 and setting a factor to a Kronecker delta. This could also be implemented in the <a class="el" href="classdai_1_1TFactor.html" title="Represents a (probability) factor.">TFactor</a> itself, which could maintain its state (ones/delta/full) and act accordingly. Update: it seems that the proposed functionality would not be enough for <a class="el" href="classdai_1_1CBP.html" title="Class for CBP (Conditioned Belief Propagation) [EaG09].">CBP</a>, for which it would make more sense to add more levels of backup/restore. </dd>
<dt>Class <a class="el" href="classdai_1_1IndexFor.html">dai::IndexFor</a>  </dt>
<dd><a class="anchor" id="_ideas000012"></a> Optimize all indices as follows: keep a cache of all (or only relatively small) indices that have been computed (use a hash). Then, instead of computing on the fly, use the precomputed ones. Here the labels of the variables don't matter, but the ranges of the variables do.  </dd>
<dt>Class <a class="el" href="classdai_1_1InfAlg.html">dai::InfAlg</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_ideas000004"></a> General marginalization functions like <a class="el" href="namespacedai.html#aab8aabfe0fcfd4b4bd24757c101449d5" title="Calculates the marginal probability distribution for vs using inference algorithm obj.">calcMarginal()</a> now copy a complete <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a> object. Instead, it would make more sense that they construct a new object without copying the <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> or <a class="el" href="classdai_1_1RegionGraph.html" title="A RegionGraph combines a bipartite graph consisting of outer regions (type FRegion) and inner regions...">RegionGraph</a>. Or they can simply be made methods of the general <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a> class. </p>
<p class="interdd"></p>
<p class="enddd">Use a <a class="el" href="classdai_1_1PropertySet.html" title="Represents a set of properties, mapping keys (of type PropertyKey) to values (of type PropertyValue)">PropertySet</a> as output of an <a class="el" href="classdai_1_1InfAlg.html" title="InfAlg is an abstract base class, defining the common interface of all inference algorithms in libDAI...">InfAlg</a>, instead of functions like <a class="el" href="classdai_1_1InfAlg.html#a915a659034eb4c85abde912d684f8dee" title="Returns maximum difference between single variable beliefs in the last iteration.">maxDiff()</a> and <a class="el" href="classdai_1_1InfAlg.html#a89986bbc1a42554905c6f417f2227ac5" title="Returns number of iterations done (one iteration passes over the complete factorgraph).">Iterations()</a>.  </p>
</dd>
<dt>Class <a class="el" href="classdai_1_1RegionGraph.html">dai::RegionGraph</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_ideas000014"></a> Generalize the definition of region graphs to the one given in [<a class="el" href="bibliography.html#YFW05">YFW05</a>], i.e., replace the current implementation which uses a <a class="el" href="classdai_1_1BipartiteGraph.html" title="Represents the neighborhood structure of nodes in an undirected, bipartite graph.">BipartiteGraph</a> with one that uses a <a class="el" href="classdai_1_1DAG.html" title="Represents the neighborhood structure of nodes in a directed cyclic graph.">DAG</a>. </p>
<p class="interdd"></p>
<p class="enddd">The outer regions are products of factors; right now, this product is constantly cached: changing one factor results in an update of all relevant outer regions. This may not be the most efficient approach; an alternative would be to only precompute the factor products at the start of an inference algorithm - e.g., in init(). This has the additional advantage that <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> e can offer write access to its factors.  </p>
</dd>
<dt>Class <a class="el" href="classdai_1_1State.html">dai::State</a>  </dt>
<dd><a class="anchor" id="_ideas000013"></a> Make the <a class="el" href="classdai_1_1State.html" title="Makes it easy to iterate over all possible joint states of variables within a VarSet.">State</a> class a more prominent part of libDAI (and document it clearly, explaining the concept of state); add more optimized variants of the <a class="el" href="classdai_1_1State.html" title="Makes it easy to iterate over all possible joint states of variables within a VarSet.">State</a> class like <a class="el" href="classdai_1_1IndexFor.html" title="Tool for looping over the states of several variables.">IndexFor</a> (e.g. for <a class="el" href="classdai_1_1TFactor.html#ae9a1373a51646795b1b6b39fd6746e79" title="Returns a slice of *this, where the subset vars is in state varsState.">TFactor&lt;&gt;::slice()</a>).  </dd>
<dt>File <a class="el" href="doc_8h.html">doc.h</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_ideas000006"></a> Adapt (part of the) guidelines in <a href="http://www.boost.org/development/requirements.html#Design_and_Programming">http://www.boost.org/development/requirements.html#Design_and_Programming</a></p>
<p class="interdd"><a class="anchor" id="_ideas000007"></a> Use "gcc -MM" to generate dependencies for targets: <a href="http://make.paulandlesley.org/autodep.html">http://make.paulandlesley.org/autodep.html</a></p>
<p class="interdd"><a class="anchor" id="_ideas000008"></a> Disentangle structures. In particular, ensure that graphical properties are not entangled with probabilistic properties. For example, a <a class="el" href="classdai_1_1FactorGraph.html" title="Represents a factor graph.">FactorGraph</a> contains several components:</p><ul>
<li>a <a class="el" href="classdai_1_1BipartiteGraph.html" title="Represents the neighborhood structure of nodes in an undirected, bipartite graph.">BipartiteGraph</a></li>
<li>an array of variable labels</li>
<li>an array of variable state space sizes</li>
<li>an array of pointers to factor value vectors In this way, each factor could be implemented differently, e.g., we could have some sparse factors, some noisy-OR factors, some dense factors, some arbitrary precision factors, etcetera.</li>
</ul>
<p class="enddd"><a class="anchor" id="_ideas000009"></a> Use boost::uBLAS framework to deal with matrices, especially, with 2D sparse matrices. See <a href="http://www.boost.org/libs/numeric/ublas/doc/matrix_sparse.htm">http://www.boost.org/libs/numeric/ublas/doc/matrix_sparse.htm</a> However: I read somewhere that boost::uBLAS concentrates more on correct implementation than on performance.  </p>
</dd>
<dt>File <a class="el" href="hak_8h.html">hak.h</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_ideas000011"></a> Implement more general region graphs and corresponding Generalized Belief Propagation updates as described in [<a class="el" href="bibliography.html#YFW05">YFW05</a>]. </p>
<p class="enddd"></p>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
